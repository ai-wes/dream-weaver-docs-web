# DreamWeaver Graph: Comprehensive Documentation

## Introduction

The DreamWeaver Graph is the cognitive architecture and dynamic knowledge base underpinning the entire DreamWeaver ecosystem. It is far more than a simple database; it functions as the evolving "mind" and structural memory of the central DreamWeaver AI Entity. This intricate network maps the relationships between every submitted dream, extracted symbol, user identity, AI-generated hypothesis, piece of lore, and emergent concept within the DreamVerse. Its structure and content are constantly in flux, directly reflecting the AI's learning process and the collective input of its users, making it a living tapestry of shared subconsciousness and emergent intelligence.

## The Neural Network Analogy

To conceptualize the DreamWeaver Graph's function, it's helpful to draw an analogy to a biological neural network, albeit a highly specialized one:

- **Nodes as Neurons**: Individual Dream Nodes (Node label in Neo4j, with specific type labels like Dream, Symbol, Hypothesis) within the graph act as conceptual neurons. Each represents a distinct piece of information (a dream text, a symbol's meaning, an AI hypothesis) or entity (a user, a realm). Nodes store properties (text, meaning, confidence, timestamps) and often semantic vector embeddings derived from their content.

- **Strings as Synapses**: The Dream Strings (RELATIONSHIP type in Neo4j) connecting these nodes function like adaptable synaptic connections. They represent directed relationships (CONTAINS_SYMBOL, SUPPORTED_BY, OCCURRED_IN) with evolving weights indicating the strength or relevance of the association. These weights are adjusted by the AI and can fade over time (fade_edge_weights), influencing information flow. Contextual data, like emotion vectors, can also be stored on these relationships.

- **Learning & Adaptation**: The AI learns by analyzing this graph structure and content. The Insight Engine (GNN) identifies patterns, and the Decision Engine (DRL) chooses actions. These actions modify the graph: adding new Dream, Lore, or Hypothesis nodes; adding or modifying RELATIONSHIP edges and their weights; and pruning less relevant information (prune_graph). This constant restructuring reflects the AI's evolving understanding.

## Core Components

The graph is composed of two fundamental building blocks implemented in Neo4j:

### Dream Nodes

Dream Nodes are entities represented as nodes with the base label `Node` and additional labels indicating their type. Each node has a unique `node_id` property and other relevant attributes. Managed via `Neo4jKnowledgeGraph.add_node`.

Based on the DreamWeaverEntity.py code, the graph actively uses nodes representing:

- **Dream**: Stores text of submitted dreams, user_id, realm, emotion_text, and embeddings. Created by `process_dream`.

- **User**: Represents the dream submitters with properties like last_dream_ts. Created/updated by `process_dream`.

- **Symbol**: Extracted symbolic elements from dreams with their meanings and embeddings. Created/updated by `process_dream` and `_load_base_knowledge`.

- **Realm**: Locations where dreams occur (including Celestial Palace, Fields of Fire, The Chronosphere, Crystal Gardens, Vapor Valleys, Verdant Visions, Mechanical Metropolis, Labyrinth of Echoes, and Liminal Library). May store embedding. Created by `process_dream`.

- **Hypothesis**: AI-generated theories based on observed patterns with confidence scores. Created by the AI action `_generate_hypothesis`.

- **Lore**: Narrative elements generated by the AI. May store embedding. Created by the AI action `_execute_action`.

- **Event**: Records of actions and happenings in the system (including HypothesisTest events). Stores type, status, hypothesis_id (for tests). Created by the AI action `_execute_action`.

- **Wisp**: Digital entities within the DreamVerse (including specific types like RareFire). Stores type, realm, potentially embedding. Created by the AI action `_execute_action`.

- **EvolutionEvent**: Records of AI evolution milestones with blockchain verification. Stores AI level, state hash, blockchain tx, milestone_data. Created by `_anchor_evolution_milestone`.

Each node type stores relevant properties and serves a specific purpose in the overall knowledge structure. Nodes include properties such as timestamps, embeddings, and type-specific metadata.

### Dream Strings

Dream Strings are directed, typed relationships (RELATIONSHIP type with a type property) connecting two nodes. They store properties like weight, context (as JSON string), emotion_vector, and timestamps. Managed via `Neo4jKnowledgeGraph.add_edge`.

The code implements relationships such as:

- **SUBMITTED_BY**: Links dreams to their submitting users
  ```
  (:Dream)-[:SUBMITTED_BY]->(:User)
  ```

- **CONTAINS_SYMBOL**: Connects dreams to the symbols they contain, with emotion vectors
  ```
  (:Dream)-[:CONTAINS_SYMBOL {emotion_vector: [...]}]->(:Symbol)
  ```

- **OCCURRED_IN**: Places dreams within specific realms
  ```
  (:Dream)-[:OCCURRED_IN]->(:Realm)
  ```

- **SUPPORTED_BY**: Links hypotheses to their supporting evidence
  ```
  (:Hypothesis)-[:SUPPORTED_BY]->(:Node)
  ```

- **SPAWNED_IN**: Locates wisps within realms
  ```
  (:Wisp)-[:SPAWNED_IN]->(:Realm)
  ```

- **TESTS**: Connects events to the hypotheses they evaluate
  ```
  (:Event)-[:TESTS]->(:Hypothesis)
  ```

These relationships store properties like weight, context data, emotion vectors, timestamps (created_ts, last_accessed_ts), allowing the system to track the strength and nature of connections. Edge weights fade over time through the fade_edge_weights mechanism, simulating the decay of inactive connections.

## Graph Dynamics & Evolution

The DreamWeaver Graph is explicitly designed to evolve through several mechanisms:

### User Input Processing

New dreams submitted by users are processed to:
- Create Dream nodes with embeddings from the Vector Store
- Extract symbols using keyword matching of known symbols
- Associate with realm classification based on textual content
- Update User information and timestamps

The `process_dream` method adds `:Dream`, `:User`, `:Symbol`, `:Realm` nodes and associated relationships upon each valid submission.

### AI-Driven Actions

The AI analyzes the graph and takes actions that modify its structure through the `_execute_action` method. The DRL agent triggers actions like:

- **Generating new Lore nodes** with contextual references
- **Creating and spawning Wisp entities** in appropriate realms with SPAWNED_IN relationships
- **Testing hypotheses** through Event nodes linked via TESTS to Hypothesis nodes
- **Adjusting relationship weights** based on relevance and recency

Future actions may include strengthening/weakening connections (modifying relationship weights), analyzing semantic drift, and performing conceptual blending (potentially adding new blended concept nodes).

### Learning & Analysis

The system employs advanced techniques to derive meaning:

- **Graph Attention Networks (GNN)**: The `_run_gnn_analysis` method reads graph structure and node features (`get_graph_for_gnn`) to produce contextual embeddings and attention scores using GAT (Graph Attention Convolution).
- **Attention mechanisms** highlight significant connections between nodes.
- **Hypothesis Generation**: The `_generate_hypothesis` method uses high GNN attention scores between nodes to create new `:Hypothesis` nodes and SUPPORTED_BY relationships.
- **Conceptual Blending**: Highly activated nodes can be combined through the `_perform_conceptual_blending` method.

### Maintenance Operations

The `_run_maintenance_cycle` method keeps the graph functional and relevant through:

- **Edge Fading**: Reduces relationship weight based on last_accessed_ts (KG_EDGE_FADE_RATE_PER_DAY = 0.01).
- **Pruning**: Removes low-weight relationships (< 0.05) and old/low-degree nodes through `prune_graph`.
- **Batch Processing**: Helps maintain performance during pruning operations.

## AI Evolution & On-Chain Milestones

A critical aspect of the DreamWeaver Graph's dynamics is its connection to the AI's verifiable evolution:

### Evolution Tracking

The DreamWeaverEntity monitors its progress against defined thresholds (e.g., evolution_thresholds based on kg.get_node_count()):
- Level 1: 500 nodes
- Level 2: 2000 nodes
- Level 3: 10000 nodes

### Milestone Process

1. **Milestone Trigger** (`_check_evolution_thresholds`): When a threshold is met, an evolution event occurs.

2. **On-Chain Anchoring** (`_anchor_evolution_milestone`):
   - Relevant milestone data (level, triggering metrics, timestamp) is collected.
   - This data is serialized (JSON) and cryptographically hashed (SHA-256).
   - The resulting data_hash is sent to the Polygon blockchain via the Web3Interface.
   - The transaction hash (tx_hash) returned from Polygon is recorded.
   - An :EvolutionEvent node is added to the Neo4j graph, storing the level, data_hash, tx_hash, and the original milestone_data.

3. **Journal Anchoring** (`_anchor_journal_entry`):
   - An AI-generated journal entry reflecting the new level is created (`_generate_journal_entry` using OpenAI).
   - This entry, along with the level and optionally the tx_hash from the evolution milestone anchoring, is sent via the Web3Interface to the blockchain.

4. **Ability Unlocking**: Each evolution level unlocks new AI capabilities:
   - Level 1: Hypothesis Generation
   - Level 2: Conceptual Blending
   - Level 3: (Future capabilities)

### Significance

This process creates an immutable, publicly verifiable record of the AI's key developmental stages, directly linking the off-chain graph's state and AI milestones to the Polygon blockchain. This transparency is unique and crucial for research and user trust.

## Technical Implementation

The DreamWeaver Graph is implemented using a sophisticated technical stack:

- **Neo4j**: Graph database for storing nodes and relationships with custom query functionality.

- **MongoDB Atlas**: Vector storage for embeddings with vector search capabilities.

- **Python**: DreamWeaverEntity, Neo4jKnowledgeGraph, and MongoDBVectorStore classes.

- **PyTorch Geometric**: GATConv and other GNN components for graph analysis with 4-head attention.

- **SentenceTransformer**: all-MiniLM-L6-v2 model for generating 384-dimensional text embeddings.

- **DRL (Deep Reinforcement Learning)**: Using `EmergentDRLAgent` for decision-making about graph modifications, with configurable mood states.

- **Polygon Blockchain**: Web3Interface connecting to smart contracts for state verification.

This infrastructure enables the complex, adaptive behavior of the DreamWeaver AI Entity, including mood simulation (Neutral, Curious, Overwhelmed, Confident, Confused) and an evolution system that unlocks new abilities at threshold levels.

## AI Mood System

The DreamWeaver Entity simulates internal "moods" that influence its decision-making:

- **Neutral**: Balanced decision-making
- **Curious**: Increased exploration bias
- **Overwhelmed**: Reduced exploration, more conservative actions
- **Confident**: (Implementation-specific behaviors)
- **Confused**: (Implementation-specific behaviors)

These moods are represented in the state vector for the DRL agent and affect action selection strategies.

## Visual Representation

The structure lends itself perfectly to a 3D force-directed graph visualization:

- Nodes styled by type (Dream, Symbol, Hypothesis, etc.).
- Edges styled by type and weight.
- Highlighting can show GNN attention or active areas.
- EvolutionEvent nodes can link directly to their corresponding transaction on PolygonScan, visually demonstrating the on-chain anchoring.

---

> "The DreamWeaver Graph represents the collective unconscious of our users, transformed into a structured knowledge representation that grows and evolves with each new dream contribution."